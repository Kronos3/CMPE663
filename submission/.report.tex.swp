% A skeleton file for producing Computer Engineering reports
% https://kgcoe-git.rit.edu/jgm6496/KGCOEReport_template

\documentclass[CMPE]{KGCOEReport}

% The following should be changed to represent your personal information
\newcommand{\classCode}{CMPE 663}  % 4 char code with number
\newcommand{\name}{Andrei Tumbar}
\newcommand{\LabSectionNum}{1}
\newcommand{\LabInstructor}{Wolfe}
\newcommand{\TAs}{Nitin Borhade}
\newcommand{\exerciseNumber}{G}
\newcommand{\exerciseDescription}{Ultrasound}

\usepackage{tikz}
\usepackage{circuitikz}
\usetikzlibrary{calc}
\usepackage{multirow}
\usepackage{titlesec}
\usepackage{float}
\usepackage{lmodern}
\usepackage{siunitx}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[usestackEOL]{stackengine}
\usepackage{scalerel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}


\def\code#1{\texttt{#1}}

\begin{document}
    \maketitle
    \section*{Analysis/Design}

    This project looked at operating an ultrasonic sensor for distance detection.
    Operation of the ultrasonic involves input capture for echo timing as well as
    polling for accurate pulse widths. \code{TIM2} was used to operate the timing
    of input and output to the sensor.

	\subsection*{Ultrasonic sensor signals}

	Other than the voltage and ground wires, the ultrasonic sensor operates with two
	signals: trigger and echo. The trigger is an input to the sensor which tell the
	sensor when to fire its output pulse. The echo pin is an output from the sensor
	that will notify when the output ping is sent and when it returns.

	\begin{figure}[h!]
      \centering
      \includegraphics[width=5.5in]{Ultrasonic}
      \caption{Ultrasonic sensor inputs and outputs}
      \label{fig:us}
    \end{figure}

	Figure \ref{fig:us} shows the pin operation for the input and output to the
	sensor. The output trigger can be easily implementing by setting the trigger
	pin high, waiting for $\SI{\sim 20}{\micro\s}$ and then setting it back to low.

    \section*{Test Plan}

    Testing the code was fairly straighforward. The UART status task was updated
    in realtime and therefore showed most of the errors on the spot. The uniform
    distrobution of the RNG could be verified by making sure the minimum and maximum
    were close to the specified boundaries as well as the average being halfway between
    the two. The seven segment display was tested using the given customer entry rates
    as well as increased rates designed to fill the queue more.

    \section*{Project Results}

    The software behaved as expected by the problem statement. All random numbers
    generated expected results and the simulation ran in the expected amount of
    time. The metrics reported at the end of the simulation showed that the parameters
    controlling the simulation as well as the design of the bank were correct.

    \section*{Lessons Learned}

	This project explored creating an embedded system on top of FreeRTOS. I learned
	how to use the API reference to quickly implement the components I needed in this
	realtime system. Task scheduling priority and preemption became clear when
	expirementing with task attributes during development. The most major issue that
	I ran into during development was a hardfault inside the teller. I created an
	efficient way to debug hardfaults (and other faults) by creating an assembly
	subroutine to extract the core registers saved when the hardfault interrupt was
	triggered. This allowed me to view the instruction and register values of the
	problematic code. The problematic code ended being related to a libc library call
	\code{vsnprintf} not being thread-safe and therefore causing issues within FreeRTOS.

	\pagebreak

	Below is an example of a hardfault occuring when overwriting part of the task
	control block (FreeRTOS's structure for keeping track of tasks) causing the
	context switcher to fault out:

	\begin{figure}[h!]
      \centering
      \includegraphics[width=5.5in]{hardfault}
      \caption{Example of hardfault handler}
      \label{fig:fault}
    \end{figure}

	Looking at the program counter in Figure \ref{fig:fault}, we can find the appropriate
	assembly instruction in the generated ELF binary. To do this, LLVM's objdump tool
	was used to decode the binary.

	\begin{figure}[h!]
      \centering
      \includegraphics[width=5.5in]{fault_pc}
      \caption{Decoded instruction at faulty program counter}
      \label{fig:fault_pc}
    \end{figure}

	In this particular instance, the task control block's stack pointer was moved to
	an invalid address therefore causing the kernel to fault out when attempting a
	context switch. This specific instruction will save the tasks core registers not
	explicitely saved by an ISR onto the tasks stack. In the future, this mechanism
	will be useful in quickly determining issues related to programming errors such
	as the one caused by non-threadsafe use of \code{vsnprintf} in this exercise.

\end{document}
